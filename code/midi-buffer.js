"use strict";
/*
 * Due to lack of module support, source code copied directly from:
 *
 *	https://www.npmjs.com/package/regroovejs@0.1.4
 *
 */
class MidiNoteEvent {
    constructor(pitch, velocity) {
        this._pitch = pitch;
        if (velocity >= 0) {
            this._velocity = velocity;
        }
    }
    static empty() {
        return new MidiNoteEvent(0, 0);
    }
    get list() {
        return [this.pitch, this.velocity];
    }
    get pitch() {
        return this._pitch;
    }
    set pitch(value) {
        this._pitch = value;
    }
    get velocity() {
        return this._velocity;
    }
    set velocity(value) {
        if (value >= 0) {
            this._velocity = value;
        }
    }
}

class MidiBuffer {
    constructor(length) {
        this.data = Array.from({ length: length }, () => MidiNoteEvent.empty());
        this.iterIndex = 0;
        this.iterCount = 0;
    }
    static fromDict(dict) {
      const entries = Object.entries(dict);
      const midiBuffer = new MidiBuffer(entries.length);
      for (const [idx, event] of entries) {
        midiBuffer.iat(idx, new MidiNoteEvent(event[0], event[1]))
      }
      return midiBuffer;
    }
    toDict() {
      const dict = {};
      for (let i = 0; i < this.length; i++) {
        dict[i.toString()] = [this.data[i].pitch, this.data[i].velocity];
      }
      return dict;
    }
    swap(other) {
        if (other.data.length === this.data.length) {
            this.data = other.data;
      }
    }
    iat(index, event) {
        if (index < this.length) {
            this.data[index] = event;
        }
    }
    get length() {
        return this.data.length;
    }
}

// API
inlets = 1

let BUFFER_LENGTH = 512;
let midiEventLoop = new Dict("midiEventLoop");
let midiBuffer = MidiBuffer.fromDict(midiEventLoop);
let pitchMapping = new Dict("midiPitchMapping")["pitch"];


function setBufferLength(v) {
  BUFFER_LENGTH = v;
}

/**
 * This method unpacks a list being generated by the
 * corresponding method code/regroove.js::prepareOutputData
 * and constructs a new MidiBuffer object.
 * 
 * The incoming list is a flat array with repeating
 * units of (bufferIndex, channelIndex, velocity) triplets.
 * 
 * @param {Array<T>} List input from Node.js runtime 
 */
function updateEventLoop(list) {
  let newMidiBuffer = new MidiBuffer(BUFFER_LENGTH);

  // add events in list to newMidiBuffer
  for (let i = 0; i < list.length / 3; i++) {
    let j = i * 3;
    let bufferIndex = list[j];
    let channelIndex = list[j+1];
    let velocity = list[j+2];
    newMidiBuffer.iat(bufferIndex, new MidiNoteEvent(pitchMapping[channelIndex.toString()], velocity));
  }
  
  // swap out old MidiBuffer and midiEventLoop dict
  midiBuffer.swap(newMidiBuffer);
  midiEventLoop = midiBuffer.toDict();
}
